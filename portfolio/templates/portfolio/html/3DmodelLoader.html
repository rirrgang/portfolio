{% load static %}
<canvas class="threejs-canvas-ms" id="model"></canvas>

<script type="module">
    //import * as THREE from 'three';
    import * as THREE from 'https://unpkg.com/three/build/three.module.js';
    //import { OrbitControls } from "{% static 'portfolio/scripts/libs/three/examples/jsm/controls/OrbitControls.js' %}"
    import { OrbitControls } from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';
    //import { GLTFLoader } from "{% static 'portfolio/scripts/libs/three/examples/jsm/loaders/GLTFLoader.js' %}"
    import { GLTFLoader } from 'https://unpkg.com/three/examples/jsm/loaders/GLTFLoader.js';
    // import { RGBELoader } from "{% static 'portfolio/scripts/libs/three/examples/jsm/loaders/RGBELoader.js' %}";
    import { RGBELoader } from 'https://unpkg.com/three/examples/jsm/loaders/RGBELoader.js';
    


    //$(document).ready(function () {
    var myCanvas = document.getElementById("model");
    var width = $(myCanvas).width();//window.innerWidth ;
    var height = $(myCanvas).height();//window.innerHeight;

    // var webglRendererContainer = $(".main-webglRenderer-container").get(0);
    // $(webglRendererContainer).css({ "width": width, "height": height });


    let camera, scene, renderer, model, controls, mixer;
    let gridHelper;
    let isAnimating = true;
    let modelLocation
    let loader;
    let animID;
    let currentRotY;
    const clock = new THREE.Clock();


    init();
    render();

    function init() {
        camera = new THREE.PerspectiveCamera(45, width / height, 0.25, 20);
        camera.position.set(10, 15, 10);

        scene = new THREE.Scene();

        //GLTF LOADER VARIABLES -------------------------------------------------------------------------------------------------
        //const rgbeTextureLocation = "{% static 'portfolio/scripts/libs/three/examples/textures/equirectangular/royal_esplanade_1k.hdr' %}" //HDR Location
        const rgbeTextureLocation = "{% static 'portfolio/pictures/HDRs/royal_esplanade_1k.hdr' %}" //HDR Location

        //const modelLocation = "{% static 'portfolio/models/Swiss_Knife.gltf' %}" 
        modelLocation = "{% static 'portfolio/models/Swiss_Knife.glb' %}" //Model Location // First model to load
        //------------------------------------------------------------------------------
        new RGBELoader().load(rgbeTextureLocation, function (texture) {

            texture.mapping = THREE.EquirectangularReflectionMapping;

            //scene.background = texture;
            scene.environment = texture;

            render();
        });

        // model
        loader = new GLTFLoader();
        loadModel(modelLocation);


        const size = 5;
        const divisions = 6;
        const colorCenterLine = new THREE.Color(0x00ff00); //green

        gridHelper = new THREE.GridHelper(size, divisions, colorCenterLine);
        scene.add(gridHelper);

        //RENDERER -------------------------------------------------------------------------------------------------
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, canvas: myCanvas });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width, height);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        renderer.outputEncoding = THREE.sRGBEncoding;

        //CONTROLS -------------------------------------------------------------------------------------------------
        controls = new OrbitControls(camera, renderer.domElement);
        //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)
        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
        controls.dampingFactor = 0.2;
        controls.screenSpacePanning = false;
        controls.minDistance = 2;
        controls.maxDistance = 10;
        controls.target.set(0, 0, - 0.2);
        controls.update();
        //controls.addEventListener('change', stopAnim);

        //RSIZE FUNCTION -------------------------------------------------------------------------------------------------
        window.addEventListener('resize', onWindowResize);
    }

    function removeAllFromScene() {
        //remove all
        for (var i = scene.children.length - 1; i >= 0; i--) {
            var obj = scene.children[i];
            scene.remove(obj);
        }
    }

    function onWindowResize() {
        var myCanvas = document.getElementById("modelContainer");
        var width = $(myCanvas).width();//window.innerWidth ;
        var height = $(myCanvas).height();//window.innerHeight;


        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);

        render();

    }
    function animate() {
        if (isAnimating) {
            if (model) {
                model.rotation.y += 0.005;
                gridHelper.rotation.y += 0.005;
                currentRotY = model.rotation.y;
                
            }
        }
        mixer.update(clock.getDelta());
        controls.update();

        animID = requestAnimationFrame(animate);

        renderer.render(scene, camera);
    };

    function toggleAnimation(bool){
        isAnimating = bool;
    }

    function render() {

        renderer.render(scene, camera);

    }

    function loadModel(src) {
        var modelNameHTML = $("#modelName");

        if (model) {
            //scene.remove(model);
            removeAllFromScene();
            scene.add(gridHelper);
            camera.position.set(10, 15, 10);
        }
        modelLocation = src;
        loader.load(src, function (gltf) {
            model = gltf.scene;
            mixer = new THREE.AnimationMixer( gltf.scene );
            gltf.animations.forEach( ( clip ) => {
                mixer.clipAction( clip ).play();    
            } );

            if (currentRotY) {
                model.rotation.y = currentRotY;
                gridHelper.rotation.y = currentRotY;
            }
            //add model
            scene.add(gltf.scene);
            render();
            if (animID) { cancelAnimationFrame(animID); }
            isAnimating = true;
            animate();
            
        }, function onProgress(progress) {
            isAnimating = false;
            //when is finished loading
            if((progress.loaded / progress.total) == 1){
                //console.log("finished");
                if(window.thumbnails){
                    var Autoplay = window.thumbnails.Components.Autoplay;
                    Autoplay.play();
                }
            }
            
            
        }, function onError(error) {
            console.log(error);
            isAnimating = false;
            
            if(modelNameHTML){
                modelNameHTML.toggleClass("video-title-error");
                modelNameHTML.html("...ERROR...");
            } 
        });
    }

    /*------------------JS Bindings-------------------------*/
    window.loadModel = loadModel;
    window.toggleAnimation = toggleAnimation;
    //});
</script>